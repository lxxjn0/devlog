---
title: "Java 코드를 테스트하는 방법, main method vs JUnit"
date: 2020-02-05
description: Java Testing way, main method and JUnit
tags:
  - Java
  - Test
slug: "/java-test-way-main-method-vs-junit"
---

이전까지의 Java 코드에 대한 테스트를 어떤 식으로 했을까?

생각해보면 main 코드에 일일이 실험할 값을 넣어서 테스트하거나 또는 System.out을 중간에 넣어가면서 확인을 하였다.

그렇다면 지금까지 우리가 테스트했던 방법인 main method와 Java의 테스팅 라이브러리인 JUnit을 테스트의 관점에서 비교해보자.

## main method로 테스트하기

먼저, 지금까지 main method를 통해 Java 코드를 테스트했다.

그렇다면 main method가 어떻게 사용되는지, 또 테스트의 용도로 사용될 때 문제점은 어떤 것들이 있는지 알아보자.

### main method의 용도

Java에서 main method는 어떤 용도로 사용되어질까?

- 프로그램을 시작

- 구현한 프로그램을 테스트

여기서 우리는 두 번째, **구현한 프로그램을 테스트**하는 방법으로 사용된 main method에 대해 살펴보겠다.

### main method로 테스트하기

```java
public class Calculator {
    int add(int i, int j) {
        return i + j;
    }

    int subtract(int i, int j) {
        return i - j;
    }

    int multiply(int i, int j) {
        return i * j;
    }

    int divide(int i, int j) {
        return i / j;
    }

    // 여기를 기준으로 위가 프로덕션 코드, 아래가 테스트 코드이다.

    public static void main(String[] args) {
        Calculator cal = new Calculator();

        System.out.println(cal.add(3, 4));
        System.out.println(cal.subtract(5, 4));
        System.out.println(cal.multiply(2, 6));
        System.out.println(cal.divide(8, 4));
    }
}
```

위 클래스의 구조는

- **Production Code** - 프로그램 구현을 담당하는 부분으로 사용자가 실제로 사용하는 소스 코드를 의미한다.

- **Test Code** - 프로덕션 코드가 정상적으로 동작하는지를 확인하는 소스 코드를 의미한다.

두 종류의 코드로 이루어져있다.

위의 예시로는 `add()`, `subtract()`, `multiply()`, `divide()` 메서드가 **Production Code**, `main()`가 **Test Code**이다.

그리고 main method를 통해 실제 Production Code를 테스트하는 상황이다.


### main method 테스트 문제점

그렇다면 main method를 통해 테스트하면 어떤 문제점들이 존재할까?

- Production Code와 Test Code가 클래스 하나에 존재한다.

    - 클래스의 **크기**가 증가한다.

    - 클래스의 **복잡도**가 증가한다.

- Test Code가 실 서비스에 같이 배포된다.

    - **불필요한 코드가 배포**되는 것이다.

- main method 하나가 **여러 개의 기능을 테스트**한다.

    - 복잡도가 증가한다.

- method 이름을 통해 어떤 부분을 테스트하는지에 대한 **의도를 드러내기 힘들다.**

- **테스트 결과를 사람이 수동으로 확인해야 한다.**

## JUnit

이번에는 기존의 방법이 아닌 새로운 테스트 방법, JUnit에 대해 알아보자.

### JUnit이란

> JUnit is a unit testing framework for the Java programming language. JUnit has been important in the development of test-driven development, and is one of a family of unit testing frameworks which is collectively known as xUnit that originated with SUnit.
>
> JUnit is linked as a JAR at compile-time; the framework resides under package junit.framework for JUnit 3.8 and earlier, and under package org.junit for JUnit 4 and later. - [wikipedia](https://en.wikipedia.org/wiki/JUnit)

[JUnit](https://junit.org/junit5/)은 Java의 단위 테스트 작성 프레임워크, 즉, 간단하게 단위 테스트를 작성할 수 있도록 도와주는 프레임워크이다.

> 다른 언어에도 xUnit이라는 단위 테스팅 도구가 존재한다. ex. CUnit, CppUnit 등

그리고 main method로 테스트를 작성할 때 발생하는 문제점을 해결하기 위해 등장한 도구이다.

조금 더 자세한 것은 추후 JUnit을 따로 다루면서 소개하도록 하겠다.

### JUnit 5.x

기본적으로 어노테이션(Annotation)을 기반으로 테스트 코드를 구현한다.

하나의 Test Class를 만들고 하위에 각각의 테스트 코드를 작성한다.

- `@Test`

- `@BeforeEach`, `@AfterEach`

- `@BeforeAll`, `@AfterAll`

- Assert 클래스의 assert method를 활용해 테스트 결과를 검증한다.

```java
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class LifecycleTest {
    @BeforeAll // JUnit 4의 @BeforeClass
    static void initAll() {
        System.out.println("initAll");
    }

    @BeforeEach // JUnit 4의 @Before
    void init() {
        System.out.println("init");
    }

    @Test
    void someTest() {
        System.out.println("someTest");
    }

    @Test
    void anyTest() {
        System.out.println("anyTest");
    }

    @AfterEach // JUnit 4의 @After
    void tearDown() {
        System.out.println("tearDown");
    }

    @AfterAll // JUnit 4의 @AfterClass
    static void tearDownAll() {
        System.out.println("tearDownAll");
    }
}
```

추가적으로 Assertion을 도와주는 도구로 [AssertJ](http://joel-costigliola.github.io/assertj/)가 있다.

```java
import static org.assertj.core.api.Assertions.*;

// basic assertions
assertThat(frodo.getName()).isEqualTo("Frodo");
assertThat(frodo).isNotEqualTo(sauron);

// chaining string specific assertions
assertThat(frodo.getName()).startsWith("Fro")
                           .endsWith("do")
                           .isEqualToIgnoringCase("frodo");

// collection specific assertions (there are plenty more)
// in the examples below fellowshipOfTheRing is a List<TolkienCharacter>
assertThat(fellowshipOfTheRing).hasSize(9)
                               .contains(frodo, sam)
                               .doesNotContain(sauron);
```

## 그렇다면 main method와 JUnit의 비교는?

위에서 JUnit은 main method를 통한 테스트의 단점을 개선하기 위해 나온 도구라고 했다.

JUnit을 main method의 문제점과 비교해본 내용은 아래와 같다.

- Production Code와 Test Code가 **분리**되어 있다. 테스트 코드는 테스트 클래스에 위치한다.

    - 각각의 코드가 클래스로 분리되어 있기 때문에 클래스의 크기도 커지지 않고 복잡성도 줄어든다.

- Test Code는 따로 Test 패키지를 통해 관리가 되고 이는 배포 시점에 포함되지 않기 때문에 **불필요한 코드를 함께 배포하지 않는다.**

- main method는 프로그램을 실행하는 역할만 수행하고 테스트 코드는 로직에 대한 테스트만 수행하기 때문에 복잡하지 않고 **각각의 책임이 명확하다.**

- **메서드 단위로 테스트**가 가능하기 때문에 **메서드 이름을 통해 테스트의 의도를 명확하게 보여줄 수 있다.**

- 테스트 결과를 System.out으로 직접 확인하지 않아도 **Assert 메서드들을 통해 확인이 가능**하고 테스트의 성공 유무도 함께 확인할 수 있다.

## 정리하면

JUnit은 이전에 main method를 통한 테스트 방법이 가지는 **문제점을 해결해주는 프레임워크**이다.

**메서드 단위로 테스트가 가능**하기 때문에 더 이상 main method에는 시나리오 단위의 테스트 코드가 있을 필요가 없게 되었다.

그로 인해 우리는 **Production Code와 Test Code를 분리**할 수 있고, 각각의 클래스는 **단일 책임**을 지키며 보다 유지보수하기 수월하다.

그러나 모든 기술은 장점을 잘 발휘하기 위해서는 잘 쓸 줄 알아야한다.

JUnit을 어떻게 하면 올바르게 사용할 수 있는지 사용법을 잘 파악하고 적용한다면 코드는 훨씬 더 깔끔하고 신뢰도 있는 코드로 유지될 것이다.

## 참고 링크

> [[JUnit] JUnit을 이용한 단위 테스트하기 + 단정(*assert*) 메서드 정리 - devuna](https://devuna.tistory.com/39)
>
> [Test-JUnit이란 - 진짜개발자](https://galid1.tistory.com/476)